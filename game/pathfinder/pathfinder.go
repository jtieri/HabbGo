package pathfinder

import (
	"container/list"
	"math"
	"strings"

	"github.com/jtieri/habbgo/game/item"
	"github.com/jtieri/habbgo/game/pathfinder/position"
	"github.com/jtieri/habbgo/game/player"
	"github.com/jtieri/habbgo/game/room"
)

const (
	MaxFallHeight = 3.0
	MaxLiftHeight = 1.5
)

var (
	DiagonalPositions = []position.Position{
		{X: 0, Y: -1, Z: 0},
		{X: 0, Y: 1, Z: 0},
		{X: 1, Y: 0, Z: 0},
		{X: -1, Y: 0, Z: 0},
		{X: 1, Y: -1, Z: 0},
		{X: -1, Y: 1, Z: 0},
		{X: 1, Y: 1, Z: 0},
		{X: -1, Y: -1, Z: 0},
	}
	// []Position{ {X: 0, Y: -1}, {X: 1, Y: 0}, {X: 0, Y: 1}, {X: -1, Y: 0}}
)

// Node represents a Node in a path which is generated by the pathfinding logic.
type Node struct {
	Position        position.Position
	NextPos         *Node
	Open            bool
	Closed          bool
	PerformanceCost int
}

// NewNode returns a new Pathfinder Node.
func NewNode(pos position.Position) *Node {
	return &Node{
		Position:        pos,
		Open:            false,
		Closed:          false,
		PerformanceCost: 0,
	}
}

// Equals returns true if the calling Node's Position is equal to the specified Node's.
func (n *Node) Equals(otherNode Node) bool {
	return n.Position.Equals(otherNode.Position)
}

// ComparePerformanceCost returns 0 if the calling Node's PerformanceCost is equal to the specified Node's.
// 1 is returned if the calling Node's PerformanceCost is greater than the specified Node's and,
// -1 is returned if the calling Node's PerformanceCost is less than the specified Node's.
func (n *Node) ComparePerformanceCost(otherNode *Node) int {
	if n.PerformanceCost == otherNode.PerformanceCost {
		return 0
	}

	if n.PerformanceCost > otherNode.PerformanceCost {
		return 1
	}

	return -1
}

// ValidStep returns true if the move from the current Position to the specified Position is an acceptable state
// transition.
func ValidStep(p *player.Player, r room.Room, currentPos, testPos position.Position, finalMove bool) bool {

	if !room.ValidTile(currentPos, r) || !room.ValidTile(testPos, r) {
		return false
	}

	startTile, err := r.Tile(currentPos.X, currentPos.Y)
	if err != nil {
		return false
	}

	endTile, err := r.Tile(testPos.X, testPos.Y)
	if err != nil {
		return false
	}

	oldHeight := startTile.WalkingHeight()
	newHeight := endTile.WalkingHeight()

	startItem := startTile.TopItem
	endItem := endTile.TopItem

	skipStartItem := skipItem(startItem, endItem)
	skipEndItem := skipItem(endItem, startItem)

	// Pathfinder makes the path from reversed, so we compare the drop reversed (To tile height against From tile height)
	if endTile.IncreaseInHeight(startTile) && (!skipStartItem && !skipEndItem) {
		if math.Abs(newHeight-oldHeight) > MaxLiftHeight {
			return false
		}
	}

	if endTile.DropInHeight(startTile) && (!skipStartItem && !skipEndItem) {
		if math.Abs(oldHeight-newHeight) > MaxFallHeight {
			return false
		}
	}

	if startTile.IncreaseInHeight(endTile) && (!skipStartItem && !skipEndItem) {
		if math.Abs(newHeight-oldHeight) > MaxLiftHeight {
			return false
		}
	}

	if startTile.DropInHeight(endTile) && (!skipStartItem && !skipEndItem) {
		if math.Abs(oldHeight-newHeight) > MaxFallHeight {
			return false
		}
	}

	// TODO handle movements in pools

	// Don't enable diagonal checking for the Sun Terrace
	// Don't allow diagonal for pool triggers
	validDiagonalStep := !(strings.HasPrefix(r.Model.Name, "sun_terrace")) &&
		!(startItem.Definition.Sprite == "poolExit") &&
		!(startItem.Definition.Sprite == "poolEnter") &&
		!(endItem.Definition.Sprite == "poolExit") &&
		!(endItem.Definition.Sprite == "poolEnter")

	// Can't walk diagonal between two non-walkable tiles
	if validDiagonalStep {
		if currentPos.X != testPos.X && currentPos.Y != testPos.Y {
			firstValidTile := room.ValidTile(position.Position{X: testPos.X, Y: currentPos.Y}, r)
			secondValidTile := room.ValidTile(position.Position{X: currentPos.X, Y: testPos.Y}, r)

			if !firstValidTile && !secondValidTile {
				return false
			}
		}
	}

	// Avoid walking into furniture unless it's their last location
	if !currentPos.Equals(r.Model.Door.Position()) {
		if finalMove {
			// Allow walking if item is walkable or trapped inside
			var containsPlayer bool
			for _, tile := range getAffectedTiles(endItem.Definition.Length, endItem.Definition.Width, endItem.State.Position.X, endItem.State.Position.Y, endItem.State.Position.BodyRotation) {
				roomTile, err := r.Tile(tile.X, tile.Y)
				if err != nil {
					return false
				}
				if roomTile.ContainsPlayer(p.Details.Id) {
					containsPlayer = true
					break
				}
			}
			return endItem.Walkable() || containsPlayer
		}
		return endItem.Definition.ContainsBehavior(item.CanSitOnTop) || endItem.GateOpen()
	}

	return true
}

// skipItem
func skipItem(itemOne, itemTwo item.Item) bool {
	if itemOne.Definition.ContainsBehavior(item.Teleporter) ||
		itemOne.Definition.Sprite == "wsJoinQueue" ||
		itemOne.Definition.Sprite == "wsQueueTile" ||
		(itemOne.Definition.Sprite == "poolEnter" && itemTwo.Definition.Sprite == "poolExit") ||
		(itemOne.Definition.Sprite == "poolExit" && itemTwo.Definition.Sprite == "poolEnter") ||
		itemOne.Definition.Sprite == "poolLift" ||
		itemOne.Definition.Sprite == "queue_tile2" {
		return true
	}
	return false
}

// getAffectedTiles
func getAffectedTiles(len, width, x, y, rotation int) []position.Position {
	var positions []position.Position

	if len != width {
		if rotation == 0 || rotation == 4 {
			tmp := len
			len = width
			width = tmp
		}
	}

	for i := x; i < x+width; i++ {
		for j := y; j < y+len; j++ {
			pos := position.Position{X: i, Y: j}
			positions = append(positions, pos)
		}
	}

	return positions
}

// NewPath generates a new path from the current Position to the specified end Position.
func NewPath(currentPos, endPos position.Position, player *player.Player, room room.Room) list.List {
	var path list.List
	pathReverse := NewPathReverse(currentPos, endPos, player, room)

	if pathReverse == nil {
		return path
	}

	// Iterate through the reversed path and build a new linked list of Position's
	for pathReverse.NextPos != nil {
		path.PushBack(pathReverse.NextPos.Position)
		pathReverse = pathReverse.NextPos
	}

	return path
}

// NewPathReverse generates a new path, from the current Position to the specified end Position, which is reversed.
func NewPathReverse(currentPos, endPos position.Position, player *player.Player, room room.Room) *Node {
	// Build a 2D slice of *Node's
	roomMap := make([][]*Node, room.MapSizeX())
	for x := 0; x < room.MapSizeX(); x++ {
		roomMap[x] = make([]*Node, room.MapSizeY())
		for y := 0; y < room.MapSizeY(); y++ {
			roomMap[x][y] = &Node{}
		}
	}

	currentNode := NewNode(currentPos)
	endNode := NewNode(endPos)

	roomMap[currentPos.X][currentPos.Y] = currentNode

	var path list.List
	path.PushBack(currentNode)

	for path.Len() > 0 {
		currentElement := path.Front()
		currentNode = currentElement.Value.(*Node)
		currentNode.Closed = true
		path.Remove(currentElement)

		for _, pos := range DiagonalPositions {
			workingPos := currentNode.Position.Add(pos) // the current Position we are working with on this iteration

			// Calculate if this is the final move necessary.
			finalMove := workingPos.X == endPos.X && workingPos.Y == endPos.Y

			if !ValidStep(player, room, currentNode.Position, workingPos, finalMove) {
				continue
			}

			var workingNode *Node
			if roomMap[workingPos.X][workingPos.Y] == nil {
				workingNode = NewNode(workingPos)
				roomMap[workingPos.X][workingPos.Y] = workingNode
			} else {
				workingNode = roomMap[workingPos.X][workingPos.Y]
			}

			if workingNode.Closed {
				continue
			}

			difference := 0

			if currentNode.Position.X != workingNode.Position.X {
				difference += 2
			}

			if currentNode.Position.Y != workingNode.Position.Y {
				difference += 2
			}

			cost := currentNode.PerformanceCost + difference + workingNode.Position.Squared(endPos)

			if cost < workingNode.PerformanceCost {
				workingNode.PerformanceCost = cost
				workingNode.NextPos = currentNode
			}

			if workingNode.Open {
				continue
			}

			// If we have calculated the path up to the specified end position then,
			// set the last node in the path and return the path from the last working node.
			if workingNode.Position.X == endNode.Position.X && workingNode.Position.Y == endNode.Position.Y {
				workingNode.NextPos = currentNode
				return workingNode
			}

			workingNode.Open = true
			path.PushBack(workingNode)
		}
	}
	return nil
}
